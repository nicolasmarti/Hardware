(**************************)

theory Wire

use import int.Int
use import bool.Bool

type t

function ([]) t int: bool

(* predicate input_stability (t: int) (delay': int) (x: t) = *)
(* 	  forall k. t - delay' <= k < t -> *)
(* 	  x[k] = x[t-delay'] *)

(* predicate output_stability (t: int) (delay': int) (x: t) = *)
(* 	  forall k. t - delay' <= k < t -> *)
(* 	  x[k] = x[t] *)

(* trying to unify both. Still unclear if it will work (morally the input need to stay stable with the first time frame of the output ... ) *)

predicate stability (t: int) (delay': int) (x: t) =
	  forall k. t - delay' <= k <= t ->
	  x[k] = x[t]

end

theory WireVector

use import Wire
use import int.Int
use import bool.Bool

type t

function ([_..]) t int: Wire.t

(* predicate input_stability (t: int) (delay': int) (x: t) (width: int) = *)
(* 	  forall n. 0 <= n < width -> *)
(* 	  forall k. t - delay' <= k < t -> *)
(* 	  x[n ..][k] = x[n ..][t-delay'] *)

(* predicate output_stability (t: int) (delay': int) (x: t) (width: int) = *)
(* 	  forall n. 0 <= n < width -> *)
(* 	  forall k. t - delay' <= k < t -> *)
(* 	  x[n ..][k] = x[n ..][t] *)

(* same unification as above *)

predicate stability (t: int) (delay': int) (x: t) (width: int) =
	  forall n. 0 <= n < width ->
	  forall k. t - delay' <= k <= t ->
	  x[n ..][k] = x[n ..][t]


end

(*************************)

theory NAND

use import Wire
use import WireVector
use import int.Int
use import bool.Bool

(**)

function in0: Wire.t
function in1: Wire.t
function out0: Wire.t

(**)

constant delay: int = 1

predicate out0_correct (t: int) (delay': int) =
	  out0[t] = notb (andb in0[t-delay'] in1[t-delay'])

axiom nand_sem: forall t: int. out0[t] = notb (andb in0[t-delay] in1[t-delay])

lemma stable:
      forall t: int.
	forall delay'. delay' >= delay ->
	Wire.stability t delay' in0 ->
	Wire.stability t delay' in1 ->
	Wire.stability t (delay' - delay) out0

lemma correct:
      forall t: int.
	forall delay'. delay' >= delay ->
	Wire.stability t delay' in0 ->
	Wire.stability t delay' in1 ->
	out0_correct t delay'


end

(************************************************************************)
(* All these gates are added in an axiom form after having begin proved *)
(************************************************************************)


theory NOT

(**)

use import int.Int
use import bool.Bool

use import Wire
use import WireVector

use NAND

(**)

constant delay: int = NAND.delay

(**)

function in0: Wire.t
function out0: Wire.t

predicate output_semantics (t: int) (delay': int) =
	out0[t] = notb in0[t-delay']


axiom stable:
	forall t: int.
	forall delay'. delay' >= delay ->
	Wire.stability t delay' in0 ->
	Wire.stability t (delay' - delay) out0

axiom correct:
	forall t: int.
	forall delay'. delay' >= delay ->
	Wire.stability t delay' in0 ->
	output_semantics t delay'

end



theory AND

(**)

use import int.Int
use import bool.Bool

use import Wire
use import WireVector

use NAND
use NOT

(**)

constant delay: int = NAND.delay + NOT.delay

(**)

function in0: Wire.t
function in1: Wire.t

function out0: Wire.t

predicate output_semantics (t: int) (delay': int) =
	out0[t] = andb in0[t-delay'] in1[t-delay']

(**)

(**)

axiom stable:
	forall t: int.
	forall delay'. delay' >= delay ->
	Wire.stability t delay' in0 ->
	Wire.stability t delay' in1 ->
	Wire.stability t (delay' - delay) out0

axiom correct:
	forall t: int.
	forall delay'. delay' >= delay ->
	Wire.stability t delay' in0 ->
	Wire.stability t delay' in1 ->
	output_semantics t delay'

end
